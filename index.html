<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Celandar</title>
    <style>
        :root {
            font-family: system-ui, Avenir, Helvetica, Arial, sans-serif;
            line-height: 1.5;
            font-weight: 400;
        }

        body {
            margin: 0;
            min-height: 100vh;
        }

        h1 {
            font-size: 3.2em;
            line-height: 1.1;
        }

        #app {
            max-width: 980px;
            margin: 0 auto;
            padding: 2rem;
        }

        #editable {
            outline: none;
            margin-bottom: 2rem;
        }

        button {
            border-radius: 8px;
            border: 1px solid transparent;
            padding: 0.75em 1.25em;
            font-size: 1em;
            font-weight: 500;
            background-color: #646cff;
            color: white;
            cursor: pointer;
        }
    </style>
</head>
<body>
<div id="app">
    <h1>Celandar</h1>
    <div id="editable" contenteditable="true"></div>
    <button id="copy">Copy</button>
</div>

<script>
    const englishKeyboard = "qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM"
    const greekKeyboard = ";ςερτυθιοπασδφγηξκλζχψωβνμ:ΣΕΡΤΥΘΙΟΠΑΣΔΦΓΗΞΚΛΖΧΨΩΒΝΜ"

    const greekToEnglish = Object.fromEntries(greekKeyboard.split('')
        .map((greek, index) => [greek, englishKeyboard[index]]))

    const englishToGreek = Object.fromEntries(englishKeyboard.split('')
        .map((english, index) => [english, greekKeyboard[index]]))

    const invertKeyboard = {...greekToEnglish, ...englishToGreek}

    const editable = document.getElementById('editable')
    const copyButton = document.getElementById('copy')

    editable.innerText = new Intl.DateTimeFormat("el-GR", {
        hour12: false,
        timeStyle: "short",
        dateStyle: "full"
    }).format(new Date()) + "\n\n\n"

    selectAll().collapseToEnd()

    editable.addEventListener('beforeinput', e => {
        if (e.data === ' ' && onSpace()) e.preventDefault();
    })

    copyButton.addEventListener('click', () => {
        selectAll();
        document.execCommand('copy');
    });

    function mapCharacters(string, map) {
        return string.split('').map(map).join('');
    }

    function selectAll() {
        editable.focus();

        const selection = window.getSelection();
        selection.selectAllChildren(editable);

        return selection;
    }

    function lastLeaf(node) {
        while (node.lastChild) {
            node = node.lastChild;
        }

        return node;
    }

    function* previousEditableTextNodes(node) {
        while (node != null && node !== editable) {
            if (node.nodeType === Node.TEXT_NODE) yield node;

            if (node.previousSibling)
                node = lastLeaf(node.previousSibling);
            else
                node = node.parentNode;
        }
    }

    function lastEditableNode(node) {
        const first = previousEditableTextNodes(lastLeaf(node)).next();
        if (first.done) return null;

        return first.value;
    }

    function invertRange(text, start, end) {
        const left = text.substring(0, start);
        const center = mapCharacters(text.substring(start, end), l => invertKeyboard[l] ?? l);
        const right = text.substring(end);

        return left + center + right;
    }

    function onSpace() {
        const selection = window.getSelection();
        if (selection.rangeCount === 0) return false; //Not editing

        const range = selection.getRangeAt(0);
        const { startContainer, endContainer, startOffset, endOffset } = range;

        if (!editable.contains(startContainer)) return false;
        if (!editable.contains(endContainer)) return false;

        const endNode = lastEditableNode(endContainer);
        if (endNode == null) return false; //Editable is completely empty

        const emptySelection = startContainer === endContainer && startOffset === endOffset;
        if (emptySelection) {
            for (const textNode of previousEditableTextNodes(endNode)) {
                const leftText = textNode === endContainer
                    ? textNode.nodeValue.substring(0, endOffset)
                    : textNode.nodeValue

                const lastWordGroups = leftText.match(/\S+(\s*)$/);
                if (lastWordGroups == null) continue;

                const [match, spaces] = lastWordGroups;
                if (textNode === endContainer && !spaces.length) return false;

                textNode.nodeValue = invertRange(
                    textNode.nodeValue,
                    lastWordGroups.index,
                    lastWordGroups.index + match.length
                );

                break;
            }
        } else {
            for (const textNode of previousEditableTextNodes(endNode)) {
                const text = textNode.nodeValue;

                let invertStart = 0;
                let invertEnd = text.length;

                if (textNode === startContainer) invertStart = startOffset;
                if (textNode === endContainer) invertEnd = endOffset;
                textNode.nodeValue = invertRange(text, invertStart, invertEnd);

                if (textNode === startContainer) break;
            }
        }

        range.setStart(startContainer, startOffset);
        range.setEnd(endContainer, endOffset);

        selection.removeAllRanges()
        selection.addRange(range);

        return true;
    }
</script>
</body>
</html>
